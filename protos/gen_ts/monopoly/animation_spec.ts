// @generated by protobuf-ts 1.0.12 with parameters disable_service_client
// @generated from protobuf file "monopoly/animation_spec.proto" (package "monopoly", syntax proto3)
// tslint:disable
import { BinaryWriteOptions } from "@protobuf-ts/runtime";
import { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import { BinaryReadOptions } from "@protobuf-ts/runtime";
import { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
import { ChanceDisplay } from "./chance";
import { PropertyInfo } from "./property";
import { Coordinate } from "./coordinate";
import { GamePlayer } from "./game_player";
import { Any } from "../google/protobuf/any";
/**
 * @generated from protobuf message monopoly.Animation
 */
export interface Animation {
    /**
     * @generated from protobuf field: string name = 1;
     */
    name: string;
    /**
     * @generated from protobuf field: monopoly.AnimationType type = 2;
     */
    type: AnimationType;
    /**
     * the duration in ms, specified when type is DEFAULT
     *
     * @generated from protobuf field: int32 length = 3;
     */
    length: number;
    /**
     * @generated from protobuf field: optional google.protobuf.Any extra = 4;
     */
    extra?: Any;
    /**
     * @generated from protobuf field: repeated monopoly.Animation children = 5;
     */
    children: Animation[];
}
/**
 * type : "animation"
 * packet_type : DEFAULT
 *
 * @generated from protobuf message monopoly.AnimationPayload
 */
export interface AnimationPayload {
    /**
     * @generated from protobuf field: monopoly.Animation animation = 1;
     */
    animation?: Animation;
}
/**
 * extra for "dice_roll"
 *
 * @generated from protobuf message monopoly.DiceRollExtra
 */
export interface DiceRollExtra {
    /**
     * @generated from protobuf field: monopoly.GamePlayer player = 1;
     */
    player?: GamePlayer;
}
/**
 * extra for "dice_down"
 * dice drop and review final number
 *
 * @generated from protobuf message monopoly.DiceDownExtra
 */
export interface DiceDownExtra {
    /**
     * @generated from protobuf field: int32 steps = 1;
     */
    steps: number;
    /**
     * @generated from protobuf field: monopoly.GamePlayer player = 2;
     */
    player?: GamePlayer;
}
/**
 * extra for "move"
 * player move along tile path
 *
 * @generated from protobuf message monopoly.MoveExtra
 */
export interface MoveExtra {
    /**
     * @generated from protobuf field: monopoly.GamePlayer player = 1;
     */
    player?: GamePlayer;
    /**
     * @generated from protobuf field: monopoly.Coordinate start = 2;
     */
    start?: Coordinate;
    /**
     * @generated from protobuf field: repeated monopoly.Coordinate path = 3;
     */
    path: Coordinate[];
}
/**
 * extra for "focus_land"
 * highlight the property for purchase
 *
 * @generated from protobuf message monopoly.FocusLandExtra
 */
export interface FocusLandExtra {
    /**
     * @generated from protobuf field: monopoly.PropertyInfo property = 1;
     */
    property?: PropertyInfo;
}
/**
 * extra for "invested"
 * show animation for purchase/upgrade
 *
 * @generated from protobuf message monopoly.InvestedExtra
 */
export interface InvestedExtra {
    /**
     * @generated from protobuf field: monopoly.PropertyInfo property = 1;
     */
    property?: PropertyInfo;
}
/**
 * extra for "pan"
 * pan camera to next player
 *
 * @generated from protobuf message monopoly.PanExtra
 */
export interface PanExtra {
    /**
     * @generated from protobuf field: monopoly.Coordinate target = 1;
     */
    target?: Coordinate;
}
/**
 * extra for "turn_start"
 * current player play ready to start animation
 *
 * @generated from protobuf message monopoly.TurnStartExtra
 */
export interface TurnStartExtra {
    /**
     * @generated from protobuf field: monopoly.GamePlayer player = 1;
     */
    player?: GamePlayer;
}
/**
 * extra for "pay_rent"
 *
 * @generated from protobuf message monopoly.PayRentExtra
 */
export interface PayRentExtra {
    /**
     * @generated from protobuf field: monopoly.GamePlayer payer = 1;
     */
    payer?: GamePlayer;
    /**
     * @generated from protobuf field: monopoly.GamePlayer payee = 2;
     */
    payee?: GamePlayer;
}
/**
 * extra for "player_emotion"
 * a general purpose animation to play to show player's emotion
 *
 * @generated from protobuf message monopoly.PlayerEmotionExtra
 */
export interface PlayerEmotionExtra {
    /**
     * @generated from protobuf field: monopoly.GamePlayer player = 1;
     */
    player?: GamePlayer;
    /**
     * @generated from protobuf field: monopoly.PlayerEmotionExtra.EmotionType emotion = 2;
     */
    emotion: PlayerEmotionExtra_EmotionType;
}
/**
 * @generated from protobuf enum monopoly.PlayerEmotionExtra.EmotionType
 */
export enum PlayerEmotionExtra_EmotionType {
    /**
     * @generated from protobuf enum value: UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0,
    /**
     * @generated from protobuf enum value: CHEER = 1;
     */
    CHEER = 1,
    /**
     * @generated from protobuf enum value: ANGRY = 2;
     */
    ANGRY = 2
}
/**
 * extra for "open_chance_chest"
 * When player arrive at the tile with chance chest, a card flyout from the
 * chance chest to the center of the screen. The current player would need
 * to click on anywhere to dismiss it after reading card. Other clients will
 * play the same animation except they won't be able to dismiss the card.
 * The card will be automatically dismissed when the current player dismiss it.
 *
 * @generated from protobuf message monopoly.OpenChanceChestExtra
 */
export interface OpenChanceChestExtra {
    /**
     * @generated from protobuf field: monopoly.Coordinate chance_chest_tile = 1;
     */
    chanceChestTile?: Coordinate;
    /**
     * @generated from protobuf field: monopoly.ChanceDisplay chance = 2;
     */
    chance?: ChanceDisplay;
}
/**
 * extra for "teleport_pickup"
 * teleport is composed of 3 animations played in sequence:
 * "teleport_pickup", "pan" and "teleport_dropoff"
 *
 * @generated from protobuf message monopoly.TeleportPickupExtra
 */
export interface TeleportPickupExtra {
    /**
     * @generated from protobuf field: monopoly.TeleportVehicle vehicle = 1;
     */
    vehicle: TeleportVehicle;
    /**
     * @generated from protobuf field: monopoly.Coordinate pickup_location = 2;
     */
    pickupLocation?: Coordinate;
    /**
     * @generated from protobuf field: monopoly.GamePlayer player = 3;
     */
    player?: GamePlayer;
}
/**
 * extra for "teleport_dropoff"
 *
 * @generated from protobuf message monopoly.TeleportDropoffExtra
 */
export interface TeleportDropoffExtra {
    /**
     * @generated from protobuf field: monopoly.TeleportVehicle vehicle = 1;
     */
    vehicle: TeleportVehicle;
    /**
     * @generated from protobuf field: monopoly.Coordinate dropoff_location = 2;
     */
    dropoffLocation?: Coordinate;
    /**
     * @generated from protobuf field: monopoly.GamePlayer player = 3;
     */
    player?: GamePlayer;
}
/**
 * @generated from protobuf enum monopoly.AnimationType
 */
export enum AnimationType {
    /**
     * @generated from protobuf enum value: DEFAULT = 0;
     */
    DEFAULT = 0,
    /**
     * container that plays child animations one by one
     *
     * @generated from protobuf enum value: SEQUENCE = 1;
     */
    SEQUENCE = 1,
    /**
     * container that plays child animations and finish when one of them finishes.
     * Other animations are truncated if possible
     *
     * @generated from protobuf enum value: RACE = 2;
     */
    RACE = 2,
    /**
     * container that plays child animations and wait for the longest one to
     * finish.
     *
     * @generated from protobuf enum value: ALL = 3;
     */
    ALL = 3
}
/**
 * How the player is being teleported. Could be things like UFO or police car.
 *
 * @generated from protobuf enum monopoly.TeleportVehicle
 */
export enum TeleportVehicle {
    /**
     * @generated from protobuf enum value: UNSPECIFIED = 0;
     */
    UNSPECIFIED = 0
}
/**
 * Type for protobuf message monopoly.Animation
 */
class Animation$Type extends MessageType<Animation> {
    constructor() {
        super("monopoly.Animation", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "type", kind: "enum", T: () => ["monopoly.AnimationType", AnimationType] },
            { no: 3, name: "length", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 4, name: "extra", kind: "message", T: () => Any },
            { no: 5, name: "children", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Animation }
        ]);
    }
    create(value?: PartialMessage<Animation>): Animation {
        const message = { name: "", type: 0, length: 0, children: [] };
        if (value !== undefined)
            reflectionMergePartial<Animation>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: Animation): Animation {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* monopoly.AnimationType type */ 2:
                    message.type = reader.int32();
                    break;
                case /* int32 length */ 3:
                    message.length = reader.int32();
                    break;
                case /* optional google.protobuf.Any extra */ 4:
                    message.extra = Any.internalBinaryRead(reader, reader.uint32(), options, message.extra);
                    break;
                case /* repeated monopoly.Animation children */ 5:
                    message.children.push(Animation.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: Animation, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* monopoly.AnimationType type = 2; */
        if (message.type !== 0)
            writer.tag(2, WireType.Varint).int32(message.type);
        /* int32 length = 3; */
        if (message.length !== 0)
            writer.tag(3, WireType.Varint).int32(message.length);
        /* optional google.protobuf.Any extra = 4; */
        if (message.extra)
            Any.internalBinaryWrite(message.extra, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* repeated monopoly.Animation children = 5; */
        for (let i = 0; i < message.children.length; i++)
            Animation.internalBinaryWrite(message.children[i], writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
export const Animation = new Animation$Type();
/**
 * Type for protobuf message monopoly.AnimationPayload
 */
class AnimationPayload$Type extends MessageType<AnimationPayload> {
    constructor() {
        super("monopoly.AnimationPayload", [
            { no: 1, name: "animation", kind: "message", T: () => Animation }
        ]);
    }
    create(value?: PartialMessage<AnimationPayload>): AnimationPayload {
        const message = {};
        if (value !== undefined)
            reflectionMergePartial<AnimationPayload>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: AnimationPayload): AnimationPayload {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* monopoly.Animation animation */ 1:
                    message.animation = Animation.internalBinaryRead(reader, reader.uint32(), options, message.animation);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: AnimationPayload, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* monopoly.Animation animation = 1; */
        if (message.animation)
            Animation.internalBinaryWrite(message.animation, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
export const AnimationPayload = new AnimationPayload$Type();
/**
 * Type for protobuf message monopoly.DiceRollExtra
 */
class DiceRollExtra$Type extends MessageType<DiceRollExtra> {
    constructor() {
        super("monopoly.DiceRollExtra", [
            { no: 1, name: "player", kind: "message", T: () => GamePlayer }
        ]);
    }
    create(value?: PartialMessage<DiceRollExtra>): DiceRollExtra {
        const message = {};
        if (value !== undefined)
            reflectionMergePartial<DiceRollExtra>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DiceRollExtra): DiceRollExtra {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* monopoly.GamePlayer player */ 1:
                    message.player = GamePlayer.internalBinaryRead(reader, reader.uint32(), options, message.player);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DiceRollExtra, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* monopoly.GamePlayer player = 1; */
        if (message.player)
            GamePlayer.internalBinaryWrite(message.player, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
export const DiceRollExtra = new DiceRollExtra$Type();
/**
 * Type for protobuf message monopoly.DiceDownExtra
 */
class DiceDownExtra$Type extends MessageType<DiceDownExtra> {
    constructor() {
        super("monopoly.DiceDownExtra", [
            { no: 1, name: "steps", kind: "scalar", T: 5 /*ScalarType.INT32*/ },
            { no: 2, name: "player", kind: "message", T: () => GamePlayer }
        ]);
    }
    create(value?: PartialMessage<DiceDownExtra>): DiceDownExtra {
        const message = { steps: 0 };
        if (value !== undefined)
            reflectionMergePartial<DiceDownExtra>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: DiceDownExtra): DiceDownExtra {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* int32 steps */ 1:
                    message.steps = reader.int32();
                    break;
                case /* monopoly.GamePlayer player */ 2:
                    message.player = GamePlayer.internalBinaryRead(reader, reader.uint32(), options, message.player);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: DiceDownExtra, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* int32 steps = 1; */
        if (message.steps !== 0)
            writer.tag(1, WireType.Varint).int32(message.steps);
        /* monopoly.GamePlayer player = 2; */
        if (message.player)
            GamePlayer.internalBinaryWrite(message.player, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
export const DiceDownExtra = new DiceDownExtra$Type();
/**
 * Type for protobuf message monopoly.MoveExtra
 */
class MoveExtra$Type extends MessageType<MoveExtra> {
    constructor() {
        super("monopoly.MoveExtra", [
            { no: 1, name: "player", kind: "message", T: () => GamePlayer },
            { no: 2, name: "start", kind: "message", T: () => Coordinate },
            { no: 3, name: "path", kind: "message", repeat: 1 /*RepeatType.PACKED*/, T: () => Coordinate }
        ]);
    }
    create(value?: PartialMessage<MoveExtra>): MoveExtra {
        const message = { path: [] };
        if (value !== undefined)
            reflectionMergePartial<MoveExtra>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MoveExtra): MoveExtra {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* monopoly.GamePlayer player */ 1:
                    message.player = GamePlayer.internalBinaryRead(reader, reader.uint32(), options, message.player);
                    break;
                case /* monopoly.Coordinate start */ 2:
                    message.start = Coordinate.internalBinaryRead(reader, reader.uint32(), options, message.start);
                    break;
                case /* repeated monopoly.Coordinate path */ 3:
                    message.path.push(Coordinate.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MoveExtra, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* monopoly.GamePlayer player = 1; */
        if (message.player)
            GamePlayer.internalBinaryWrite(message.player, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* monopoly.Coordinate start = 2; */
        if (message.start)
            Coordinate.internalBinaryWrite(message.start, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated monopoly.Coordinate path = 3; */
        for (let i = 0; i < message.path.length; i++)
            Coordinate.internalBinaryWrite(message.path[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
export const MoveExtra = new MoveExtra$Type();
/**
 * Type for protobuf message monopoly.FocusLandExtra
 */
class FocusLandExtra$Type extends MessageType<FocusLandExtra> {
    constructor() {
        super("monopoly.FocusLandExtra", [
            { no: 1, name: "property", kind: "message", T: () => PropertyInfo }
        ]);
    }
    create(value?: PartialMessage<FocusLandExtra>): FocusLandExtra {
        const message = {};
        if (value !== undefined)
            reflectionMergePartial<FocusLandExtra>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FocusLandExtra): FocusLandExtra {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* monopoly.PropertyInfo property */ 1:
                    message.property = PropertyInfo.internalBinaryRead(reader, reader.uint32(), options, message.property);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FocusLandExtra, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* monopoly.PropertyInfo property = 1; */
        if (message.property)
            PropertyInfo.internalBinaryWrite(message.property, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
export const FocusLandExtra = new FocusLandExtra$Type();
/**
 * Type for protobuf message monopoly.InvestedExtra
 */
class InvestedExtra$Type extends MessageType<InvestedExtra> {
    constructor() {
        super("monopoly.InvestedExtra", [
            { no: 1, name: "property", kind: "message", T: () => PropertyInfo }
        ]);
    }
    create(value?: PartialMessage<InvestedExtra>): InvestedExtra {
        const message = {};
        if (value !== undefined)
            reflectionMergePartial<InvestedExtra>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InvestedExtra): InvestedExtra {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* monopoly.PropertyInfo property */ 1:
                    message.property = PropertyInfo.internalBinaryRead(reader, reader.uint32(), options, message.property);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InvestedExtra, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* monopoly.PropertyInfo property = 1; */
        if (message.property)
            PropertyInfo.internalBinaryWrite(message.property, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
export const InvestedExtra = new InvestedExtra$Type();
/**
 * Type for protobuf message monopoly.PanExtra
 */
class PanExtra$Type extends MessageType<PanExtra> {
    constructor() {
        super("monopoly.PanExtra", [
            { no: 1, name: "target", kind: "message", T: () => Coordinate }
        ]);
    }
    create(value?: PartialMessage<PanExtra>): PanExtra {
        const message = {};
        if (value !== undefined)
            reflectionMergePartial<PanExtra>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PanExtra): PanExtra {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* monopoly.Coordinate target */ 1:
                    message.target = Coordinate.internalBinaryRead(reader, reader.uint32(), options, message.target);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PanExtra, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* monopoly.Coordinate target = 1; */
        if (message.target)
            Coordinate.internalBinaryWrite(message.target, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
export const PanExtra = new PanExtra$Type();
/**
 * Type for protobuf message monopoly.TurnStartExtra
 */
class TurnStartExtra$Type extends MessageType<TurnStartExtra> {
    constructor() {
        super("monopoly.TurnStartExtra", [
            { no: 1, name: "player", kind: "message", T: () => GamePlayer }
        ]);
    }
    create(value?: PartialMessage<TurnStartExtra>): TurnStartExtra {
        const message = {};
        if (value !== undefined)
            reflectionMergePartial<TurnStartExtra>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TurnStartExtra): TurnStartExtra {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* monopoly.GamePlayer player */ 1:
                    message.player = GamePlayer.internalBinaryRead(reader, reader.uint32(), options, message.player);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TurnStartExtra, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* monopoly.GamePlayer player = 1; */
        if (message.player)
            GamePlayer.internalBinaryWrite(message.player, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
export const TurnStartExtra = new TurnStartExtra$Type();
/**
 * Type for protobuf message monopoly.PayRentExtra
 */
class PayRentExtra$Type extends MessageType<PayRentExtra> {
    constructor() {
        super("monopoly.PayRentExtra", [
            { no: 1, name: "payer", kind: "message", T: () => GamePlayer },
            { no: 2, name: "payee", kind: "message", T: () => GamePlayer }
        ]);
    }
    create(value?: PartialMessage<PayRentExtra>): PayRentExtra {
        const message = {};
        if (value !== undefined)
            reflectionMergePartial<PayRentExtra>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PayRentExtra): PayRentExtra {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* monopoly.GamePlayer payer */ 1:
                    message.payer = GamePlayer.internalBinaryRead(reader, reader.uint32(), options, message.payer);
                    break;
                case /* monopoly.GamePlayer payee */ 2:
                    message.payee = GamePlayer.internalBinaryRead(reader, reader.uint32(), options, message.payee);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PayRentExtra, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* monopoly.GamePlayer payer = 1; */
        if (message.payer)
            GamePlayer.internalBinaryWrite(message.payer, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* monopoly.GamePlayer payee = 2; */
        if (message.payee)
            GamePlayer.internalBinaryWrite(message.payee, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
export const PayRentExtra = new PayRentExtra$Type();
/**
 * Type for protobuf message monopoly.PlayerEmotionExtra
 */
class PlayerEmotionExtra$Type extends MessageType<PlayerEmotionExtra> {
    constructor() {
        super("monopoly.PlayerEmotionExtra", [
            { no: 1, name: "player", kind: "message", T: () => GamePlayer },
            { no: 2, name: "emotion", kind: "enum", T: () => ["monopoly.PlayerEmotionExtra.EmotionType", PlayerEmotionExtra_EmotionType] }
        ]);
    }
    create(value?: PartialMessage<PlayerEmotionExtra>): PlayerEmotionExtra {
        const message = { emotion: 0 };
        if (value !== undefined)
            reflectionMergePartial<PlayerEmotionExtra>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: PlayerEmotionExtra): PlayerEmotionExtra {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* monopoly.GamePlayer player */ 1:
                    message.player = GamePlayer.internalBinaryRead(reader, reader.uint32(), options, message.player);
                    break;
                case /* monopoly.PlayerEmotionExtra.EmotionType emotion */ 2:
                    message.emotion = reader.int32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: PlayerEmotionExtra, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* monopoly.GamePlayer player = 1; */
        if (message.player)
            GamePlayer.internalBinaryWrite(message.player, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* monopoly.PlayerEmotionExtra.EmotionType emotion = 2; */
        if (message.emotion !== 0)
            writer.tag(2, WireType.Varint).int32(message.emotion);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
export const PlayerEmotionExtra = new PlayerEmotionExtra$Type();
/**
 * Type for protobuf message monopoly.OpenChanceChestExtra
 */
class OpenChanceChestExtra$Type extends MessageType<OpenChanceChestExtra> {
    constructor() {
        super("monopoly.OpenChanceChestExtra", [
            { no: 1, name: "chance_chest_tile", kind: "message", T: () => Coordinate },
            { no: 2, name: "chance", kind: "message", T: () => ChanceDisplay }
        ]);
    }
    create(value?: PartialMessage<OpenChanceChestExtra>): OpenChanceChestExtra {
        const message = {};
        if (value !== undefined)
            reflectionMergePartial<OpenChanceChestExtra>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: OpenChanceChestExtra): OpenChanceChestExtra {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* monopoly.Coordinate chance_chest_tile */ 1:
                    message.chanceChestTile = Coordinate.internalBinaryRead(reader, reader.uint32(), options, message.chanceChestTile);
                    break;
                case /* monopoly.ChanceDisplay chance */ 2:
                    message.chance = ChanceDisplay.internalBinaryRead(reader, reader.uint32(), options, message.chance);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: OpenChanceChestExtra, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* monopoly.Coordinate chance_chest_tile = 1; */
        if (message.chanceChestTile)
            Coordinate.internalBinaryWrite(message.chanceChestTile, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* monopoly.ChanceDisplay chance = 2; */
        if (message.chance)
            ChanceDisplay.internalBinaryWrite(message.chance, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
export const OpenChanceChestExtra = new OpenChanceChestExtra$Type();
/**
 * Type for protobuf message monopoly.TeleportPickupExtra
 */
class TeleportPickupExtra$Type extends MessageType<TeleportPickupExtra> {
    constructor() {
        super("monopoly.TeleportPickupExtra", [
            { no: 1, name: "vehicle", kind: "enum", T: () => ["monopoly.TeleportVehicle", TeleportVehicle] },
            { no: 2, name: "pickup_location", kind: "message", T: () => Coordinate },
            { no: 3, name: "player", kind: "message", T: () => GamePlayer }
        ]);
    }
    create(value?: PartialMessage<TeleportPickupExtra>): TeleportPickupExtra {
        const message = { vehicle: 0 };
        if (value !== undefined)
            reflectionMergePartial<TeleportPickupExtra>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TeleportPickupExtra): TeleportPickupExtra {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* monopoly.TeleportVehicle vehicle */ 1:
                    message.vehicle = reader.int32();
                    break;
                case /* monopoly.Coordinate pickup_location */ 2:
                    message.pickupLocation = Coordinate.internalBinaryRead(reader, reader.uint32(), options, message.pickupLocation);
                    break;
                case /* monopoly.GamePlayer player */ 3:
                    message.player = GamePlayer.internalBinaryRead(reader, reader.uint32(), options, message.player);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TeleportPickupExtra, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* monopoly.TeleportVehicle vehicle = 1; */
        if (message.vehicle !== 0)
            writer.tag(1, WireType.Varint).int32(message.vehicle);
        /* monopoly.Coordinate pickup_location = 2; */
        if (message.pickupLocation)
            Coordinate.internalBinaryWrite(message.pickupLocation, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* monopoly.GamePlayer player = 3; */
        if (message.player)
            GamePlayer.internalBinaryWrite(message.player, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
export const TeleportPickupExtra = new TeleportPickupExtra$Type();
/**
 * Type for protobuf message monopoly.TeleportDropoffExtra
 */
class TeleportDropoffExtra$Type extends MessageType<TeleportDropoffExtra> {
    constructor() {
        super("monopoly.TeleportDropoffExtra", [
            { no: 1, name: "vehicle", kind: "enum", T: () => ["monopoly.TeleportVehicle", TeleportVehicle] },
            { no: 2, name: "dropoff_location", kind: "message", T: () => Coordinate },
            { no: 3, name: "player", kind: "message", T: () => GamePlayer }
        ]);
    }
    create(value?: PartialMessage<TeleportDropoffExtra>): TeleportDropoffExtra {
        const message = { vehicle: 0 };
        if (value !== undefined)
            reflectionMergePartial<TeleportDropoffExtra>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: TeleportDropoffExtra): TeleportDropoffExtra {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* monopoly.TeleportVehicle vehicle */ 1:
                    message.vehicle = reader.int32();
                    break;
                case /* monopoly.Coordinate dropoff_location */ 2:
                    message.dropoffLocation = Coordinate.internalBinaryRead(reader, reader.uint32(), options, message.dropoffLocation);
                    break;
                case /* monopoly.GamePlayer player */ 3:
                    message.player = GamePlayer.internalBinaryRead(reader, reader.uint32(), options, message.player);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: TeleportDropoffExtra, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* monopoly.TeleportVehicle vehicle = 1; */
        if (message.vehicle !== 0)
            writer.tag(1, WireType.Varint).int32(message.vehicle);
        /* monopoly.Coordinate dropoff_location = 2; */
        if (message.dropoffLocation)
            Coordinate.internalBinaryWrite(message.dropoffLocation, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* monopoly.GamePlayer player = 3; */
        if (message.player)
            GamePlayer.internalBinaryWrite(message.player, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
export const TeleportDropoffExtra = new TeleportDropoffExtra$Type();
